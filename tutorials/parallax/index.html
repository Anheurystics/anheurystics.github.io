<!DOCTYPE html>
<html>
<head>
	<link rel="shortcut icon" href="../../images/dnlg-icon.ico">
	<link rel="stylesheet" type="text/css" href="../../css/style.css">
	<link rel="stylesheet" type="text/css" href="../css/tut_style.css">
	<link rel="stylesheet" type="text/css" href="../css/default.css">
	
	<script type="text/javascript" src="../../js/jquery-1.11.1.min.js"></script>
	<script type="text/javascript" src="../../js/jquery.color-2.1.2.min.js"></script>
	<script type="text/javascript" src="js/parallax_demo.js"></script>	
	<script type="text/javascript" src="../js/highlight.pack.js"></script>
	
	<script>
	$(document).ready(function () {
		$('.navlink').hover(function () {
			$(this).animate({
				color: 'white'
			}, 150);
		}, function () {
			$(this).animate({
				color: 'black'
			}, 150);
		});
	});

	hljs.initHighlightingOnLoad();
	hljs.configure({tabReplace: '    '})
	</script>
	<title>Anheurystics' Blog</title>
</head>
	<body>
		<img src="../../images/banner.png" id="banner">
		<div style="text-align:center;">
			<navbar>
				<a href="../../" class="navlink" > ./home </a>
				<a href="../../games" class="navlink"> ./games </a>
				<a href=".." class="navlink"> ./tutorials </a>
			</navbar>
		</div>
	<span id="title">Parallax Background Scrolling in Video Games</span>
	<span id="last_update">Last updated: May 16, 2015</span>
	<p>
	In this tutorial, I will be showing you how to have a scrolling parallax background in your game. While I will be using Java-like pseudocode to demonstrate the code snippets, the ideas presented in this tutorial can of course be implemented in any programming language using (almost) any kind of API.
	<br/><br/>
	<i style="font-size: 16px;">
	<b>Note:</b> I added the "almost" part because even if any game created in any engine/framework can have this effect, the approach I will be discussing here can only be used in frameworks that allow you to manually draw a sprite/image at a specified location. In engines or frameworks where those operations are abstracted by a pre-defined camera (eg. Unity, GamerMaker), a different method must be used to achieve parallax scrolling. Frameworks such as Swing, HTML5 canvas, or Actionscript 3 work well for this purpose.
	</i>
	</p>
	<p>
	The Parallax effect is an effect that, besides being observable in real life, can also be scene in various video games and websites. To simply put it, a parallax effect is when objects farther away from you "move" or get displaced a bit slower than nearer objects. 
	<br/><br/>
	In 3D games and scenes, this effect can be observed naturally with far away objects or background elements. In 2D games, however, this is usually faked programatically to achieve depth in an otherwise flat display. To help illustrate this effect, I've created a small demo. 	Notice how not all of the stars move at the same rate when you move the camera around. Some stars move around slower than the others (which are the ones "farther" from you).
	</p>
	<canvas id="parallax_demo" width="500px" height="400px" tabIndex="1" class="code_demo"></canvas>
	<p>
	We can now begin with the procedures used. We will be using the two images for demonstration, <a href="images/starfield1.png">starfield1.png</a> and <a href="images/starfield2.png">starfield2.png</a> , respectively. Both images will have white dots for stars, but while starfield1.png will have an opaque black background, starfield2.png will have a transparent one (so that we'll be able to see starfield1.png)
	</p>
	<pre>
	<code class="java">class ParallaxDemo
{
    //Assume that these are already loaded beforehand
	Image starField1;
	Image starField2;

	void drawScene()
	{
		//This is where the drawing happens
		drawImage(starField1, 0, 0);
		drawImage(starField2, 0, 0);
	}
}
	</code></pre>
	<p>So far, we have a very simple setup here: we draw the two starfield images with their upper-left corners at the origin. If we were to run this, then we would just be seeing the demo's initial state. Let us now add a camera, to allow us to move the scene around.</p>
	<pre>
	<code class="java">class ParallaxDemo
{
	//Assume that these are already loaded beforehand
	Image starField1;
	Image starField2;

	//Set the initial upper-left position of the camera to be at (0, 0)
	double cameraX = 0;
	double cameraY = 0;

	void updateScene()
	{
		if(isKeyDown(KEY_W)) cameraY -= cameraMoveSpeed;
		if(isKeyDown(KEY_S)) cameraY += cameraMoveSpeed;
		if(isKeyDown(KEY_A)) cameraX -= cameraMoveSpeed;
		if(isKeyDown(KEY_D)) cameraX += cameraMoveSpeed;
	}

	void drawScene()
	{
		//This is where the drawing happens
		drawImage(starField1, 0, 0);
		drawImage(starField2, 0, 0);
	}
}
	</code></pre>
	<p>Simple enough. We have two variables to store the x and y position of the camera, respectively. We check for the key state to be able to change these values using the WASD keys. At the moment, however, we still haven't given the camera values influence over how the scene is drawn. Let us stop and think for a moment how we would do this. 
	<br/><br/>
	Say that we have an object with its origin at (100, 100), in terms of the world's space in pixels.
	<br/>If the camera was at (0, 0), then we would see the object at its original stated position on the screen, which is (100, 100)
	<br/>If we moved the camera over to (50, 50) however, the object would appear on the screen at (50, 50), even if its actual world position is (100, 100). 
	<br/>Finally, if we moved the camera over to (200, 200) however, the object's screen position would be at (-100, -100), meaning that it would not be visible on the screen at all. The three images below better illustrate these points.
	</p>
	<div style="text-align:center;"><div style="display:inline-block;">
	<img src="images/demo1.png"></img>
	<img src="images/demo2.png"></img>
	<img src="images/demo3.png"></img>
	</div></div>
	<p>From these observations, we can conclude that the screen position of an object at (x, y) with a camera at (cx, cy) is (x - cx, y - cy). In other words, we subtract the actual world position of the object by the camera's position to get its screen position. We will then incorporate this into our code</p>
	<pre>
	<code class="java">class ParallaxDemo
{
	//Assume that these are already loaded beforehand
	Image starField1;
	Image starField2;

	//Set the initial upper-left position of the camera to be at (0, 0)
	double cameraX = 0;
	double cameraY = 0;

	void updateScene()
	{
		if(isKeyDown(KEY_W)) cameraY -= cameraMoveSpeed;
		if(isKeyDown(KEY_S)) cameraY += cameraMoveSpeed;
		if(isKeyDown(KEY_A)) cameraX -= cameraMoveSpeed;
		if(isKeyDown(KEY_D)) cameraX += cameraMoveSpeed;
	}

	void drawScene()
	{
		//This is where the drawing happens
		//Note that since our starfields will be drawn at (0, 0), we just end up negating the camera's X and Y values
		drawImage(starField1, -cameraX, -cameraY);
		drawImage(starField2, -cameraX, -cameraY);
	}
}
	</code></pre>
	<p>To see this in action, go back to the demo, toggle parallax OFF, and then try moving around. We can see that the parallax effect is still not achieved, given that both images are moving at the same rate. This is where the crucial part comes in. Remember that to achieve parallax effect, layers that are farther should move slower, while layers that are closer should move faster. In this case, our layer for starfield1 should move slower than our layer for starfield2. To change the speed with which an object/layers moves in, we have to multiple the rate (depending on the layer) to the camera's offset. 
	<br/><br/>In the case of the demo, the rate for starfield1 is 0.75 (slower movement) while the rate for starfield2 is 1.00 (movement rate the same as the camera's)</p>

	<pre>
	<code class="java">void drawScene()
{
	//This is where the drawing happens
	//Note that since our starfields will be drawn at (0, 0), we just end up negating the camera's X and Y values
	drawImage(starField1, -cameraX * layer1Rate, -cameraY * layer1Rate);
	drawImage(starField2, -cameraX * layer2Rate, -cameraY * layer2Rate);
}
	</code></pre>

	<p>
	There you have it, a simple parallax scrolling background code. You should get results similar to the demo above (with parallax ON). As you can see, given that we had to implement our own basic camera (one that only applies translation), trying to implement this in a framework or engine with a fully-fledged camera (translation, rotation, scale, FOV, etc) would be a bit more convoluted.
	<br/><br/>
	As with all game effect tricks, be careful as to not overdo this trick. While the parallax effect can indeed give a 2D game much-needed depth, having 20 or so layers, each with different scroll values, might just end up confusing your player. Find the perfect balance of number of layers and their individual scroll rates.
	<br/><br/>
	<i style="font-size: 16px;">
	<b>Addendum:</b> Having a layer with a scroll rate of 0 means that it will never move along with the camera. This works well if you want to create a transparent layer filled with GUI elements that you want to stay on the screen</i>
	</p>
</body>

</html>